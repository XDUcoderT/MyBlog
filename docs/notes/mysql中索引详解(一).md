---
title: mysql中索引详解(一)
permalink: /post/undefined.html
date: 2023-01-04 22:42:29
meta:
  - name: keywords
    content: ''
  - name: description
    content: >-
      mysql中索引详解(一)本文参考了小林coding(强烈推荐)图灵学院以及稀土掘金社区at_竹子爱熊猫的文章概述我们可以把存在数据库中的数据比作字典中的汉字那么索引就相当于拼音排序或者笔画数排序。所以索引是把存入数据库的data有序组织起来的工具分类按照数据结构mysql索引常见的数据结构有btreehashfulltextbtree首先来看一下btree​它的所有节点都存储数据然后再观察btree​相比于btree具有以下特点非叶子节点不存储data只存储索引(冗余索引)这样每一层可以放更多的索引叶子
tags: []
categories: []
author:
  name: XDUcoderT
  link: https://github.com/XDUcoderT
---

#  mysql中索引详解(一)

> 本文参考了小林coding(强烈推荐)、图灵学院以及稀土掘金社区@竹子爱熊猫的文章

## 概述

我们可以把存在数据库中的数据比作字典中的汉字，那么索引就相当于拼音排序 或者 笔画数排序。所以，索引是把存入数据库的data有序组织起来的工具

## 分类

### 按照数据结构

MySQL索引常见的数据结构有B+Tree、Hash、Full-text

#### B+Tree

首先来看一下B-Tree  
​![image.png](http://xducodert001.oss-cn-hangzhou.aliyuncs.com/articles/d89ee2b86299d0b7c826b4977df488cc.png)  
它的所有节点都存储数据

然后再观察B+Tree  
​![image.png](http://xducodert001.oss-cn-hangzhou.aliyuncs.com/articles/c124d725f71136659ad2e9b550fa5a59.png)  
相比于B-Tree，具有以下特点

1. 非叶子节点不存储data，只存储索引(冗余索引)，这样每一层可以放更多的索引
2. 叶子节点包含所有索引字段
3. 叶子节点用指针连接，这样可以提高区间访问的性能

#### Hash

* 优点：

  * 对索引的key进行一次hash计算就可以定位出数据存储的位置
  * 很多时候ahsh索引要比B+ 树索引更高效
* 缺点

  * 仅能满足“=”，“in”这种等值查询，不支持范围查询
  * 存在hash冲突问题  
    ​![image.png](http://xducodert001.oss-cn-hangzhou.aliyuncs.com/articles/1d296cbe01a05b69b6cc9621abdc2f7d.png)​

> 面试题：B+tree和其他数据结构的比较

首先我们来了解一下**为什么不同数据结构的索引为何会对查询速度有影响 ​**或者说 **影响mysql查询速度的底层原因是什么**

之前在[mysql整体架构](http://47.109.37.170/articles/56)一文中说过，mysql的索引和数据记录都是保存在磁盘中的(持久化保存)。

我们每次通过索引查询某行数据的过程如下：

先从磁盘读取索引到内存，再通过索引从磁盘中找到数据，然后读入到内存，所以查询过程中会发生多次磁盘IO。

磁盘查询速度比内存要慢上数万倍。所以提高查询速度的关键降低磁盘IO的次数。另外，mysql是支持范围查找的，所以索引的数据结构需要支持范围查询(hash不行)

综上所述，要设计一个适合mysql索引的数据结构，需要满足

* 能在尽可能少的磁盘I/O操作中完成查询工作
* 能够完成范围查询工作

最合适的数据结构就是B+树！

回到原来的问题。下面给出对比

> B+Tree vs B Tree

* B+ 树的非叶子节点仅存放索引，因此数据量相同的情况下，相比所有节点既存索引又存记录的B树，B+树的非叶子节点可以存放更多的索引，因此可以减少磁盘I/O次数
* B+树的非叶子节点都是从叶子节点中抽取出来的中间索引，也叫做荣誉索引，所以B+树在入删除的效率比B树高
* B+树叶子节点通过双向链表连接起来，有利于范围查询，B树只能通过树的遍历来实现范围查询。

B+树更深入可以看小林这篇文章[换一个角度看B+树](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247502059&idx=1&sn=ccbee22bda8c3d6a98237be769a7c89c&scene=21#wechat_redirect)

> B+Tree vs 二叉树

* 对于普通二叉树，其具有退化为链表的风险
* 对于平衡二叉树如红黑树，因为每个根节点的只能有两个叶子节点，其搜索时间复杂度也远高于B+Tree

> B+Tree vs Hash  
> Hash只适合做等值查询，对于范围查询并不适用。

### 按照物理存储

* 聚簇索引：也叫主键索引，叶子节点存放的是完整的数据。
* 辅助索引：也叫二级索引，叶子节点存放的是主键值。

### 按照字段特点

* 主键索引  
  主键索引就是建立在主键字段上的索引，一张表有且仅有一个。  
  主键索引的确定规则：如果有主键那么就是主键，如果没有主键，则找一个唯一索引作为主键索引，如果没有唯一索引，那就用隐藏的id列来作为主键索引。
* 唯一索引  
  一张表可以有多个唯一索引，且允许空值
* 普通索引  
  字段可以不唯一
* 前缀索引  
  字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，目的是为了减少索引占用的存储空间，提升查询效率。

  ```sql
  CREATE INDEX index_name
  ON table_name(column_name(length)); 
  ```

### 按照字段个数分类

按照字段个数来分类的话可以分为单列索引和联合索引。

* 建立在单列上的索引称为单列索引
* 建立在多列上的索引称为联合索引

#### 联合索引

通过将多个字段组合成一个索引，该索引就被称为联合索引。

##### 最左匹配原则

按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。

原则口诀**：**

1. **全局无序则无法使用索引。**

2. **左起局部有序可以使用索引。**

3. **可过滤的话可以使用索引。**

4. **前一个字段无序后一个字段必定无序。**

全局无序： where后面的任何一个条件只要是全局无序则无法使用索引。

例1：创建了一个 `(a, b, c)`​ 联合索引，以下三种就会索引失效。

​`1.where b=2`​  `2.where c=3`​  `3.where b=2 and c=3`​

因为他们是全局无序的，无法根据索引定位(原则3 -> 原则1)

‍

例2：创建了一个 `(a, b, c)`​ 联合索引，执行以下操作

`select * from t_table where a > 1 and b = 2`

由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a > 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 a > 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a > 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。

**但是在符合 a &gt; 1 条件的二级索引记录的范围里，b 字段的值是无序的。因此，我们不能根据查询条件 b = 2 来进一步减少需要扫描的记录数量。b 字段无法利用联合索引进行索引查询。**

对于a: 原则2(只不过是特殊的原则2，全局有序)，可以使用索引

对于b: 原则1，无法使用索引

‍

例3：创建了一个 `(a, b, c)`​ 联合索引，执行以下操作

`select * from t_table where a >= 1 and b = 2`

虽然在符合 a>= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，**但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的**

对于a: 原则2(只不过是特殊的原则2，全局有序)，可以使用索引

对于b: 原则2，可以走索引

‍

例4：创建了一个 `(a, b, c)`​ 联合索引，执行以下操作

`SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2`

​`a BETWEEN 2 AND 8`​ 的意思是查询 a 字段的值在 2 和 8 之间的记录。不同的数据库对 BETWEEN ... AND 处理方式是有差异的。在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，类似于 >= and =<，**对于符合 a = 2 的二级索引记录的范围里，b 字段的值是「有序」的**

对于a: 原则2(只不过是特殊的原则2，全局有序)，可以使用索引

对于b: 原则2，可以走索引

‍

例5：创建了一个 `(a, b, c)`​ 联合索引，执行以下操作

`SELECT * FROM t_user WHERE name like 'j%' and age = 22`

a 字段可以在联合索引的 B+Tree 中进行索引查询，形成的扫描区间是['j','k')。注意， j 是闭区间,**所以对于符合 name = j 的二级索引记录的范围里，age字段的值是「有序」的**

对于a: 原则2(只不过是特殊的原则2，全局有序)，可以使用索引

对于b: 原则2，可以走索引

综上所述

**联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配**

‍

##### 索引下推

对于联合索引（a, b），在执行 `select * from table where a > 1 and b = 2`​ 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？

* 在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。
* 而 MySQL 5.6 引入的​**索引下推优化**​（index condition pushdown)， ​**可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数**​。

当你的查询语句的执行计划里，出现了 Extra 为 `Using index condition`​，那么说明使用了索引下推的优化。

‍

##### 索引优缺点

**优点：**

提高查询速度

**缺点：**

* 需要**占用物理空间**，数量越大，占用空间越大；
* **创建索引和维护索引**要耗费时间，这种时间随着数据量的增加而增大；
* **会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护**。

#### 是否使用索引

因为索引有利有弊，所以创建索引需要根据具体的场景。

**使用索引**

* 字段有**唯一性限制的**，比如商品编码；
* **经常用于 ​**​**`WHERE`**​**​ 查询条件的字段**，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
* **经常用于 ​**​**`GROUP BY`**​**​ 和 ​**​**`ORDER BY`**​**​ 的字段，这样在查询的时候就不需要再去做一次排序了**，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。

  唯一性 经常where 需要排序

**不适用索引**

* ​`WHERE`​​ 条件，`GROUP BY`​​，`ORDER BY`​​ 里用不到的字段，**索引的价值是快速定位**，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
* **字段中存在大量重复数据**，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。
* **表数据太少的时候，不需要创建索引**；
* **经常更新**的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。

  **重复、太少、经常更新**

‍

‍
