---
title: mysql的并发控制
permalink: /post/mysql-s-concurrent-control-z11rgjb.html
date: 2023-01-17 19:39:02
meta:
  - name: keywords
    content: ''
  - name: description
    content: >-
      mysql的并发控制乐观并发控制本质乐观并发控制也叫乐观锁它假设用户并发的事务在处理时不会彼此相互影响各事务能够在不产生锁的情况下处理各自影响的那部分数据乐观并发控制对数据修改持乐观态度认为即使在并发环境中外界对数据的操作一般是不会造成冲突所以并不会去加锁而是在提交数据更新之前每个事务会先检查在事务读取数据后有没有其他事务又修改了该数据。如果其他事务有更新的话则让返回冲突信息让用户决定如何去做下一步比如重试或者回滚。可以看出乐观锁其实也不是实际的锁甚至没有用到锁来实现并发控制而是采取其他方式来判断能否修改
tags: []
categories: []
author:
  name: XDUcoderT
  link: https://github.com/XDUcoderT
---

# mysql的并发控制

# 乐观并发控制

## 本质

乐观并发控制也叫乐观锁，它假设用户并发的事务在处理时不会彼此相互影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据

乐观并发控制对数据修改持乐观态度，认为即使在并发环境中，外界对数据的操作一般是不会造成冲突，所以并不会去加锁，而是在提交数据更新之前，**每个事务会先检查在事务读取数据后，有没有其他事务又修改了该数据**。如果其他事务有更新的话，则让返回冲突信息，让用户决定如何去做下一步，比如重试或者回滚。

可以看出，**乐观锁其实也不是实际的锁**，甚至没有用到锁来实现并发控制，而是采取其他方式来判断能否修改数据。乐观锁一般是用户自己实现的一种锁机制，虽然没有用到实际的锁，但是能产生加锁的效果。

## 实现方式

CAS（比较与交换，Compare and swap） 是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。实现非阻塞同步的方案称为“无锁编程算法”（ Non-blocking algorithm）。

乐观锁基本都是基于 CAS（Compare and swap）算法来实现的。我们先来看下CAS过程，一个CAS操作的过程可以用以下c代码表示:

```c
intcas(long*addr,longold,longnew)
{
    /* Executes atomically. */
    if(*addr!= old)
        return0;
    *addr= new;
    return1;
}
```

CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。整个CAS操作是一个原子操作，是不可分割的。

乐观锁实现方式：

1. 版本号标记：在表中新增一个字段：version，用于保存版本号。获取数据的时候同时获取版本号，然后更新数据的时候用以下命令:**updatexxx set version=version+1,… where … version=&quot;old version&quot; and ....**。这时候通过判断返回结果的影响行数是否为0来判断是否更新成功，更新失败则说明有其他请求已经更新了数据了。
2. 时间戳标记：和版本号一样，只是通过时间戳来判断。一般来说很多数据表都会有**更新时间**这一个字段，通过这个字段来判断就不用再新增一个字段了。
3. 待更新字段：如果没有时间戳字段，而且不想新增字段，那可以考虑用待更新字段来判断，因为更新数据一般都会发生变化，那更新前可以拿要更新的字段的旧值和数据库的现值进行比对，没有变化则更新。
4. 所有字段标记：数据表所有字段都用来判断。这种相当于就、不仅仅对某几个字段做加锁了，而是对整个数据行加锁，只要本行数据发生变化，就不进行更新

## 优缺点

优点：

不会实际加锁，所以没有额外开销，也不会出现死锁问题。

缺点：

由于其核心操作与cas类似，以version实现方式为例，需要带上version进行匹配，并且同时执行version+1的操作，所以会严重影响到数据库性能。所以乐观锁适合于写多读少的业务场景

‍

# 悲观并发控制

## 本质

悲观并发控制也叫做悲观锁，是一种并发控制的方法，它可以阻止一个事务以影响其他用户的方式来修改数据。**如果一个事务执行的操作读某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。**

事实上我们常说的悲观锁并不是一种实际的锁，而是一种并发控制的思想，悲观并发控制对于数据被修改持悲观的态度，认为数据被外界访问时，必然会产生冲突，所以在数据处理的过程中都采用加锁的方式来保证对资源的独占。

**数据库的锁机制其实都是基于悲观并发控制的观点进行实现的**，而且按照实际使用情况，数据库的锁又可以分为许多种类.

## 实现方式

数据库悲观锁的加锁流程大致如下：

1. 开启事物后，按照操作类型给需要加锁的数据申请加某一类锁，例如共享行锁等
2. 加锁成功则继续后面的操作，**如果数据已经被加了其他的锁，而且和现在要加的锁冲突，则会加锁失效**(例如已经加了排他锁)，此时需要等待其他的锁释放(可能出现死锁)
3. 完成事务后释放所加的锁

## 优缺点

优点：

悲观并发控制采取的是保守策略：“先取锁，成功了才访问数据”，这保证了数据获取和修改都是有序进行的，因此适合在**写多读少**的环境中使用。当然使用悲观锁无法维持非常高的性能，但是在乐观锁也无法提供更好的性能前提下，悲观锁却可以做到保证数据的安全性。

缺点：

1. 由于需要加锁，而且可能面临锁冲突甚至死锁的问题
2. 增加了系统的额外开销，降低了系统的效率

# MVCC多版本并发控制

## 概述

前面的两种并发控制机制确实能够从根本上解决并发事务的可串行化的问题，但是其实都是在解决写冲突的问题，两者区别在于对写冲突的乐观程度不同(**悲观锁也能解决读写冲突问题，但是性能就一般了**)。而在实际使用过程中，数据库读请求是写请求的很多倍，我们如果能解决读写并发的问题的话，就能更大地提高数据库的读性能，而这就是多版本并发控制所能做到的事情。

我们之前学过mysql的锁机制，其有效地解决了脏读不可重复读幻读等并发问题。但是这种串行化的加锁操作会降低mysql的性能。

MVCC实现了不加锁解决读-写并发冲突。从而确保了任何时刻的读操作都是非阻塞的

总的来说，MVCC的出现就是数据库不满用悲观锁去解决读-写冲突问题，因性能不高而提出的解决方案。

## 底层原理

MVCC通过隐藏字段，Undo-log日志，ReadView这三样工具实现

### 隐藏字段

InnoDB种主要有以下四个隐藏字段。

#### 隐藏主键 - ROW_ID

我们在[mysql种索引详解(一)](http://47.109.37.170/articles/59)中谈到【主键索引的确定规则：如果有主键那么就是主键，如果没有主键，则找一个唯一索引作为主键索引，如果没有唯一索引，那就用隐藏的id列来作为主键索引。】  
这里的隐藏字段就是顺序递增的列ROW_ID

#### 删除标识 - Deleted_Bit(1 Bits)

mysql删除某条记录是先进行逻辑删除，而不是直接删除数据。然后再由purger线程来进行删除。也就相当于先判死刑，然后过段时间再执行，防止有翻案的情况。

purger也会维护一个Read_View来判断字段是否可见。

#### TRX_ID

InnoDB每个事务有一个唯一的id，transaction_id,是严格递增的。

数据表中的一行记录可能有多个版本，每个版本都有一个row trx_id。新的版本可以通过undo_log来访问旧版本。

举例：当前最新版本是 V4，k 的值是 22，它是被 transaction id = 25 的事务更新的，因此它的 row trx_id 也是 25。  
​![image.png](http://xducodert001.oss-cn-hangzhou.aliyuncs.com/articles/8d57b7a1ebc8412cfa0a472194c82527.png)  
U1,U2,U3 这些箭头就是 undo log  
V1、V2、V3 并不真实存在的，  
而是每次需要的时候根据当前版本和 undo log (箭头后退)计算出来的。

#### 回滚指针 ROLL-PTR

全称为rollback-pointer。当一个事务对一条数据做了改动后，就会将旧版本的数据放到Undo-log中，而rollback-pointer就是一个地址指针，指向Undo-log日志中旧版本的数据，当需要回滚事务时，就可以通过这个隐藏列，来找到改动之前的旧版本数据。

### Undo-log日志

Undo-log实际上是存储了一条版本链，  
版本链其实就是一条把多个版本穿起来的单向链表。每次改动都是一个新的版本。也就是一个事务可以产生多个版本。

举例：

```mysql
SELECT * FROM `zz_users` WHERE user_id = 1;
+---------+-----------+----------+----------+---------------------+
| user_id | user_name | user_sex | password | register_time       |
+---------+-----------+----------+----------+---------------------+
|       1 | 熊猫      | 女       | 6666     | 2022-08-14 15:22:01 |
+---------+-----------+----------+----------+---------------------+

UPDATE `zz_users` SET user_name = "竹子" WHERE user_id = 1;
UPDATE `zz_users` SET user_sex = "男" WHERE user_id = 1;

```

undo-log中存储形式  
​![image.png](http://xducodert001.oss-cn-hangzhou.aliyuncs.com/articles/7cddf167ff7d63e9d3f3183bdc67d591.png)​

> 详细过程：  
> ①对ID=1这条要修改的行数据加上排他锁。  
> ②将原本的旧数据拷贝到Undo-log的rollback Segment区域。  
> ③对表数据上的记录进行修改，修改完成后将隐藏字段中的trx_id改为当前事务ID。  
> ④将隐藏字段中的roll_ptr指向Undo-log中对应的旧数据，并在提交事务后释放锁

### ReadView

一个事务在尝试读取一条数据时，MVCC基于当前MySQL的运行状态生成的快照，也被称之为读视图，即ReadView，在这个快照中记录着当前所有活跃事务的ID（活跃事务是指还在执行的事务，即未结束（提交/回滚）的事务）。

可重复读 (mysql默认隔离级别):  
数据库里在事务启动时创建一个视图,  
(start transaction with consistent snapshot; 开始视图, 这句只有在可重复读时有效, 读提交 时 只是普通的开始事务)  
整个事务存在期间看到的值都用这个视图。

就是 这个事务启动的时刻为准，如果一个数据版本(row trx_id)是在启动之前生成的，就不可见, 继续往前找( 用undo log回退 )。

ReadView一般包含以下四个字段

* creator_trx_id：代表创建当前这个ReadView的事务ID。
* trx_ids：表示在生成当前ReadView时，系统内活跃的事务ID列表。活跃事务就是启动了还未提交的数据。
* up_limit_id：活跃的事务列表中，最小的事务ID。**低水位**
* low_limit_id：表示在生成当前ReadView时，系统中要给下一个事务分配的ID值。**高水位**

> 高水位不一定是自己, 因为事务启动申请自己的事务 和 构造这个数组 之间有时间差, 可能有其他事务产生

其中 READ COMMITTED 和 REPEATABLE READ 生成时机不同。

> READ COMMITTED —— 每次读取数据前都生成一个ReadView  
> 在一个事务中每次 select 可能的数据不一样，因为生成的 ReadView 每次都会重新生成。
>
> 所以可能生成的ReadView会不一样，主要体现在可能会有事务提交 就不在trx_ids里面

> REPEATABLE READ —— 在第一次读取数据时生成一个ReadView  
> 在一个事务中每次 select 都是一样，因为生成的 ReadView 每次都是一样的。

​![image.png](http://xducodert001.oss-cn-hangzhou.aliyuncs.com/articles/ec1e5a1d60e8debfe1f605e3daed35fc.png)​

判断规则  
1.绿色: 我开始前提交的,直接可见  
2.红色: 我开始后开始的,直接不可见  
3.黄色, 需要查数组,数组里面如果有这条记录，说明还未提交，则需要找历史版本中的第一条不在黄色中的版本记录。  
不在数组中，则已经提交，可以见到。

### 快照读和当前读

#### 快照读

快照读也叫做普通读，就是利用MVCC机制读取快照中的数据。

比如：

```sql
SELECT * FROM user WHERE ...
```

* 快照读是基于MVCC实现的，提高了并发的性能，降低开销。
* 大部分业务代码的读取都属于快照读。

#### 当前读

当前读读取的是记录的最新版本，读取时会对读取的记录进行加锁，其他事务就会堵塞。

加锁的 SELECT，或者对数据进行增删改都会进行当前读

> SELECT * FROM user LOCK IN SHARE MODE; # 共享锁  
> SELECT * FROM user FOR UPDATE; # 排他锁  
> INSERT INTO user values ... # 排他锁  
> DELETE FROM user WHERE ... # 排他锁  
> UPDATE user SET ... # 排他锁

> 举例  
> 事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；

事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；

三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。

事务 A(100) 数组: [99,100], 低水位99 高水位100  
事务 B(101) 数组: [99,100,101], 低水位99 ,高水位102  
事务 C(102) 数组: [99,100,101,102]. 低水位99.高水位102

​![image.png](http://xducodert001.oss-cn-hangzhou.aliyuncs.com/articles/528945dd82e6f06149fb38d6ca280b64.png)​

A事务(100) 数组: [99,100]:  
虽然最先开始,但是做了其他的事,最后来读取这行  
查询语句的读数据流程是这样的：

找到最新的 (1,3) 的时候， row trx_id=101，比高水位100大，不可见；  
undo log 往前找，找到上一个历史版本，一看 row trx_id=102，比高水位100大，不可见；  
undo log 往前找,找到了（1,1)，它的 row trx_id=90，比低水位99小，处于绿色区域，可见  
A事务(100) 什么时候读都是(1,1),看到这行数据的结果都是一致的，所以我们称之为一致性读。

> 补充 ：  
> begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。

## 优缺点

优点：

MVCC使大多数读操作都可以不用加锁，这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。

缺点：

每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。

# 使用场景

## **一、悲观锁**

1. 用来解决读-写冲突和写-写冲突的的加锁并发控制
2. 适用于写多读少，写冲突严重的情况，因为悲观锁是在读取数据的时候就加锁的，读多的场景会需要频繁的加锁和很多的的等待时间，而在写冲突严重的情况下使用悲观锁可以保证数据的一致性
3. 数据一致性要求高
4. 可以解决脏读，幻读，不可重复读，第一类更新丢失，第二类更新丢失的问题

## **二、乐观锁**

1. 解决写-写冲突的无锁并发控制
2. 适用于读多写少，因为如果出现大量的写操作，写冲突的可能性就会增大，业务层需要不断重试，这会大大降低系统性能
3. 数据一致性要求不高，但要求非常高的响应速度
4. 无法解决脏读，幻读，不可重复读，但是可以解决更新丢失问题

## **三、MVCC**

1. 解决读-写冲突的无锁并发控制
2. 与上面两者结合，提升它们的读性能
3. 可以解决脏读，幻读，不可重复读等事务问题，更新丢失问题除外

‍
