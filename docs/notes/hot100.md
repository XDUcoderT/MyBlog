---
title: hot100
date: 2023-01-16T00:33:24Z
lastmod: 2023-03-13T23:17:21Z
---

# hot100

```
title: hot100
tags: 刷题
category: /学习/算法/做题总结
renderNumberedHeading: true
grammar_cjkRuby: true
```

# Hot100

**Hot01**

**题目描述**

```
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
​
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
​
你可以按任意顺序返回答案。
```

**实例**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**题解**

```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length;i++){
            if(map.get(nums[i]) == null){
                map.put(target-nums[i],i);
            }else{
                return new int[]{i,map.get(nums[i])};
            }
        }
        return new int[]{0,0};
    }
}
```

**总结**

```
用map就能解决
```

**Hot02**

**题目描述**

```
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
​
请你将两个数相加，并以相同形式返回一个表示和的链表。
​
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
```

**实例**

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**题解**

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // ListNode nl1 = reverse(l1);
        // ListNode nl2 = reverse(l2);
        ListNode head = new ListNode();
        ListNode node = head;
        int carry = 0;
        int num = 0;
        int value = 0;
        while(l1 != null && l2 != null){
            num  = l1.val + l2.val + carry;
            value  = num % 10;
            carry = num/10;
            node.next = new ListNode(value);
            node = node.next;
            l1 = l1.next;
            l2 = l2.next;
        }
        while(l1 != null){
            num = l1.val + carry;
            value  = num % 10;
            carry = num/10;
            node.next = new ListNode(value);
            node = node.next;
            l1 = l1.next;
        }
        while(l2 != null){
            num = l2.val + carry;
            value  = num % 10;
            carry = num/10;
            node.next = new ListNode(value);
            node = node.next;
            l2 = l2.next;
        }
        if(carry != 0){
            node.next = new ListNode(carry);
        }
        return head.next;
    }
}
```

**总结**

```
常见的归并问题，注意边界条件就行，最后的carry是否为0判断比较重要
```

**Hot04**

**题目描述**

```
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
```

**实例**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**题解**

```
class Solution {
    public int lengthOfLongestSubstring(String s) {
        //维护一个最长的字符串
        //考虑用map来记录 key是字符 value是位置
        int maxlen = 0;
        Map<Character,Integer> map = new HashMap<>();
        char[] chars = s.toCharArray();
        int len = chars.length;
        int begin = 0;
        for(int i = 0; i < len;i++){
            char c = chars[i];
            if(map.get(c) == null){
                map.put(c,i);
            }
            else{
                int idx = map.get(c);
                for(int j = begin; j <= idx;j++){
                    char ch = chars[j];
                    map.remove(ch);
                }
                map.put(c,i);
                begin = idx + 1;
            }
            maxlen = Math.max(map.size(),maxlen);
        }
        maxlen = Math.max(map.size(),maxlen);
        for(Map.Entry entry : map.entrySet()){
            char c = (char)entry.getKey();
            System.out.println(c);
        }
        return maxlen;
    }
}
```

**总结**

```
本题是常见的滑动窗口类题目
```

**Hot05**

**题目描述**

```
给你一个字符串 s，找到 s 中最长的回文子串。
```

**实例**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**题解**

```
class Solution {
    public String longestPalindrome(String s) {
        Map<Integer,Character> map = new HashMap<>();
        char[] chars = s.toCharArray();
        int len = s.length();
        for(int i = 0;i < len;i++){
            map.put(i,chars[i]);
        }
        int maxlen = 1;
        int left = 0;
        int right = 0;
        for(double i = 0; i < len;i+=0.5){
            int temp = 0;
            if((int)i * 2 == (int)(i*2))
            temp++;
            for(int j = (int)i + 1;j < len;j++){
                int idx = (int)(2*i) - j;
                if(idx < 0){
                    break;
                }
                if(map.get(idx) == map.get(j)){
                    temp += 2;
                    if(temp > maxlen){
                        maxlen = temp;
                        left = idx;
                        right = j;
                    }
                }else{
                    break;
                }
            }
        }
        String res = s.substring(left,right+1);
        return res;
    }
}
```

**总结**

```
这道题就是要注意回文串串中心可能是0.5的位置
```

**Hot06**

**题目描述**

```
给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。
```

**实例**

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**题解**

```
class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1, result = 0;

        while (left < right) {
            int width = right - left;
            int minHigh = Math.min(height[left], height[right]);
            result = Math.max(width * minHigh, result);

            while (height[left] <= minHigh && left < right) {
                left++;
            }
            while (height[right] <= minHigh && left < right) {
                right--;
            }
        }

        return result;
    }
}
```

**总结**

```
这道题就是典型的贪心,yysy我感觉贪心的题没有固定的套路 纯靠现场想
这道题就是长边不可能往里缩，只有短边往里缩，那就让短边一直往里缩就好了
```

**Hot07**

**题目描述**

```
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请

你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。
```

**实例**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**题解**

```
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
       int n = nums.length;
       Arrays.sort(nums);
       List<List<Integer>> res = new ArrayList<>();
       for(int i = 0;i < n; i++){
            //这个大循环遍历的是第一个数字
            if(i >0 && nums[i] == nums[i-1]){
               continue; //去除重复的
            }
            int a = nums[i];
            int target = 0 - a;
            int t = n-1;
            for(int j = i + 1;j < n;j++){
                if(j > i+1  && nums[j] == nums[j-1]){
                    continue; //去除重复的
                }
                while(t > j && nums[t] + nums[j] > target){
                    t--;
                }
                if(t == j){
                    break;
                }
                if(nums[t] + nums[j] == target){
                    List<Integer> list = new ArrayList<>();
                    list.add(nums[t]);
                    list.add(nums[j]);
                    list.add(nums[i]);
                    res.add(list);
                }
            }
       }
       return res;
    }
}
```

**总结**

```
其实就是加一维的滑动窗口，双指针解决滑动窗口问题 滑动窗口一般是从过饱和状态通过移动双指针来逼近饱和状态 双指针符合一定一动的规律
```

**Hot08**

**题目描述**

```
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
```

**实例**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**题解**

```
class Solution {

    // 数字到号码的映射
    private String[] map = {"abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};


    // 结果集
    private List<String> res = new ArrayList<>();
    private int target;
    public List<String> letterCombinations(String digits) {
        target = digits.length();
        if(digits == null || digits.length() == 0) return res;
        char[] chars = digits.toCharArray();
        int[] nums = new int[target];
        int i = 0;
        for(char c: chars){
            int index = c - '2';
            nums[i] = index;
            i++;
        }
        dfs("",0,nums);
        return res;
    }

    public void dfs(String path,int idx,int[] nums){
        if(path.length() == target){
            res.add(path);
            return;
        }
        String str = map[nums[idx]];
        char[] cur = str.toCharArray();
        for(char ch : cur){
            String curPath = path + ch;
            dfs(curPath,idx+1,nums);
        }
    }

  
}
```

**总结**

```
还是暴力递归
这道题是顺序遍历确定当前节点 而且这道题节点是必选的 
```

**Hot09**

**题目描述**

```
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
```

**实例**

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

**题解**

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head.next == null){
            return null;
        }
        ListNode fast = head;
        ListNode slow = head;
        while(n > 0){
            fast = fast.next;
            n--;
        }
        if(fast == null){
            return head.next;
        }
        while(fast.next != null){
            slow = slow.next;
            fast = fast.next;
        }
        slow.next = slow.next.next;
        return head;
    }
}
```

**总结**

```
常见题
```

**Hot10**

**题目描述**

```
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。
```

**实例**

```
输入：s = "()"
输出：true
```

**题解**

```
class Solution {
    public boolean isValid(String s) {
        Deque<Character> deque = new LinkedList();
        char[] chars = s.toCharArray();
        int len = chars.length;
        for(int i = 0;i < len; i++){
            char ch = chars[i];
            if(ch == '(' || ch == '[' || ch == '{'){
                deque.addLast(ch);
            }
            else{
                if(deque.size() == 0){
                    return false;
                }
                char c = deque.getLast();
                if((c == '(' && ch == ')') || (c == '[' && ch == ']') || (c == '{' && ch == '}')){
                    deque.removeLast();
                }else{
                    return false;
                }
            }
        }
        if(deque.size() == 0){
            return true;
        }
        return false;
    }
}
```

**总结**

```
就是简单的栈练习 注意java中栈使用双端队列实现的
Deque queue = new Linkedlist();
```

**Hot11**

**题目描述**

```
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
```

**实例**

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**题解**

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode res = new ListNode();
        ListNode node = res;
        while(list1 != null && list2 != null){
            int val1 = list1.val;
            int val2 = list2.val;
            if(val1 == val2){
                node.next = new ListNode(val1);
                node.next.next = new ListNode(val1);
                node = node.next.next;
                list1 = list1.next;
                list2 = list2.next;
            }
            if(val1 < val2){
                node.next = new ListNode(val1);
                list1 = list1.next;
                node = node.next;
            }
            if(val1 > val2){
                node.next = new ListNode(val2);
                list2 = list2.next;
                node = node.next;
            }
        }
        if(list1 != null){
            node.next = list1;
        }
        if(list2 != null){
            node.next = list2;
        }
        return res.next;
    }
}
```

**总结**

```
就是简单的归并
```

**Hot12**

**题目描述**

```
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 
```

**实例**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**题解**

```
class Solution {
    List<String> res = new ArrayList<>();
    public List<String> generateParenthesis(int n) {
        int left = n;
        int right = n;
        dfs("(",left-1,right);
        return res;
    }
  

    public void dfs(String path,int left,int right){
        System.out.println(path + " " + left + " " + right);
        if(left == 0 && right == 0){
            res.add(path);
            return;
        }
        if(left == 0){
            String newpath = path + ')';
            dfs(newpath,left,right-1);
            return;
        }
        if(left == right){
            String newpath = path + '(';
            dfs(newpath,left-1,right);
            return;
        }
        //上面是三个减枝直接return即可
        else{
            String newpath1 = path + '(';
            dfs(newpath1,left-1,right);
            String newpath2 = path + ')';
            dfs(newpath2,left,right-1);
        }
    }
}
```

**总结**

```
减枝的结果直接return即可 
```

**Hot13**

**题目描述**

```
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
```

**实例**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**题解**

```
class Solution {
    public int longestValidParentheses(String s) {
        int maxans = 0;
        int[] dp = new int[s.length()];
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == ')') {
                if (s.charAt(i - 1) == '(') {
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxans = Math.max(maxans, dp[i]);
            }
        }
        return maxans;
    }
}
```

**总结**

```
动态规划 反正我他妈是不会
```

**Hot15**

**题目描述**

```
给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。
```

**实例**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**题解**

```
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left = -1;
        int right = -1;
        int begin = 0;
        int end = nums.length - 1;
        int index = -1;
        while(begin <= end){ 
            int mid = begin + (end - begin)/2; 
            if(nums[mid] == target){
                index = mid;
                break;
            }
            if(nums[mid] > target){
                end = mid - 1;
            }else{
                begin = mid + 1;
            }
        }
        if(index == -1){
            return new int[]{left,right};
        }
        int i = 0;
        for(i = index;i > 0;i--){
            if(nums[i - 1] != nums[i]){
                break;
            }
        }
        left = i;
         for( i = index;i < nums.length-1;i++){
            if(nums[i + 1] != nums[i]){
                break;
            }
        }
        right = i;
        return new int[]{left,right};
    }
}
```

**总结**

```
这道题其实就还好啦 就是二分查找 target数就行
```

**Hot16**

**题目描述**

```
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
```

**实例**

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**题解**

```
class Solution {
    public int trap(int[] height) {
        int sum = 0;
        //最两端的列不用考虑，因为一定不会有水。所以下标从 1 到 length - 2
        for (int i = 1; i < height.length - 1; i++) {
            int max_left = 0;
            //找出左边最高
            for (int j = i - 1; j >= 0; j--) {
                if (height[j] > max_left) {
                    max_left = height[j];
                }
            }
            int max_right = 0;
            //找出右边最高
            for (int j = i + 1; j < height.length; j++) {
                if (height[j] > max_right) {
                    max_right = height[j];
                }
            }
            //找出两端较小的
            int min = Math.min(max_left, max_right);
            //只有较小的一段大于当前列的高度才会有水，其他情况不会有水
            if (min > height[i]) {
                sum = sum + (min - height[i]);
            }
        }
        return sum;
    }
}
```

**总结**

```
这道题就是有点像数学题的感觉 技巧性比较强 记住一下思路就行了 遍历 然后找左右最高 然后将当前列高度与左右最高进行比较 进行判断
```

**Hot17**

**题目描述**

```
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
```

**实例**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]。 
```

**题解**

```
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        List<Integer> rest = new ArrayList<>();
        for(int i = 0; i < len;i++){
            rest.add(nums[i]);
        }
        List<Integer> path = new ArrayList<>();
        dfs(rest,path);
        return res;
    }

    public void dfs(List<Integer> rest,List<Integer> path){
        if(rest.isEmpty()){
           res.add(path);
        }
        int size = rest.size();
        for(int i = 0;i < size; i++){
            List<Integer> newpath = new ArrayList<>(path);
            newpath.add(rest.get(i));
            List<Integer> newrest = new ArrayList<>(rest);
            newrest.remove(i);
            dfs(newrest,newpath);
        }
      
    }
}
```

**总结**

```
就是简单的递归
```

**Hot18**

**题目描述**

```
给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
```

**实例**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

**题解**

```
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<Integer> path = new ArrayList<>();
        List<Integer> rest = new ArrayList<>();
        Arrays.sort(nums);
        int len = nums.length;
        for(int i = 0;i < len; i++){
            rest.add(nums[i]);
        }
        dfs(rest,path);
        return res;
    }

    public void dfs(List<Integer> rest,List<Integer> path){
        if(rest.isEmpty()){
            res.add(path);
            return;
        }
        int size = rest.size();
        for(int i = 0;i < size;i++){
            if(i > 0 && rest.get(i) == rest.get(i - 1)){
                continue;
            }
            List<Integer> newpath = new ArrayList<>(path);
            newpath.add(rest.get(i));
            List<Integer> newrest = new ArrayList<>(rest);
            newrest.remove(i);
            dfs(newrest,newpath);
        }
    }
}
```

**总结**

```
确实是简单的暴力递归 是全排列题型中 需要对每层进行去重的操作
```

**Hot19**

**题目描述**

```
给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
```

**实例**

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

**题解**

```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int end = n/2;
        for(int i = 0;i < end; i++){
            int t = n -i -1;
            swap(matrix,i,i,t,i);
            swap(matrix,t,i,t,t);
            swap(matrix,t,t,i,t);
            for(int j = i+1;j < t;j++){
                swap(matrix,j,i,t,j);
                swap(matrix,t,j,t-j+i,t);
                swap(matrix,t-j+i,t,i,t-j+i);
            }
        }
    }


    public void swap(int[][] matrix,int x1,int y1,int x2,int y2){
        int temp = matrix[x1][y1];
        matrix[x1][y1] = matrix[x2][y2];
        matrix[x2][y2] = temp;
    }
}
```

**总结**

```
就是傻逼数学题 能不能死一死啊
```

**Hot20**

**题目描述**

```
给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。
```

**实例**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

**题解**

```
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res = new ArrayList<>();
        int len = strs.length;
        Map<String,List<String>> map = new HashMap<>();
        for(int i = 0; i < len;i++){
            String str = strs[i];
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            String newstr = new String(chars);
            Set<String> keys = map.keySet();
            if(keys.contains(newstr)){
                map.get(newstr).add(str);
            }else{
                List<String> list = new ArrayList<>();
                list.add(str);
                map.put(newstr,list);
            }								   
        }

        for(Map.Entry<String,List<String>> entry : map.entrySet()){
            List<String> list = entry.getValue();
            res.add(list);								      
        }
        return res;
    }
  
    public boolean eq(String s1,String s2){
       	char[] chars1 = s1.toCharArray();
       	char[] chars2 = s2.toCharArray();
       	if(chars1.length != chars2.length){
       	    return false; 
       	}
       	Arrays.sort(chars1);
       	Arrays.sort(chars2);
       	String newstr1 = new String(chars1);
       	String newstr2 = new String(chars2);
       	return newstr1.equals(newstr2);
    }
} 
```

**总结**

```
异位词建议用我这种方法 用map key为按字典序排序后的异位词，value就是这个key的所有异位词的list集合
```

**Hot21**

**题目描述**

```
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。
```

**实例**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**题解**

```
class Solution {
    public int maxSubArray(int[] nums) {
        int max = Integer.MIN_VALUE;
        int premax = 0;
        int len = nums.length;
        for(int i = 0;i < len; i++){
            int num = nums[i];
            if(num > premax && premax < 0){
                premax = num;
            }else{
                premax += num;
            }
            max = Math.max(premax,max);
        }
        return max;
    }
}
```

**总结**

```
这种题不是很难，感觉有点像前缀和，遍历到当前节点得到包括当前节点的最大前缀和 
```

**Hot22**

**题目描述**

```
给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。
```

**实例**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**题解**

```
class Solution {
    public boolean canJump(int[] nums) {
        int len = nums.length;
        boolean[] dp = new boolean[len];
        dp[len - 1] = true;
        for(int i = len -2;i >= 0; i-- ){
            int num = nums[i];
            for(int j = 1;j <= num; j++){
                if(i + j < len){
                    dp[i] = dp[i] | dp[i+j];
                }
            }
        }
        return dp[0];
    }
}
```

**总结**

```
就是简单的动态规划
```

**Hot23**

**题目描述**

```
以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
```

**实例**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**题解**

```
class Solution {
    public int[][] merge(int[][] intervals) {
        List<int[]> res = new ArrayList<>();
        for(int[] ints : intervals){
            res.add(ints);
        }
        res.sort(new Comparator<int[]>(){
            @Override
            public int compare(int[] ints1,int[] ints2){
                return ints1[0] - ints2[0];
            }
        });
        //我认为合并区间主要有两种情况 
        //1.交叉：ints1[1] >= ints2[0] && ints1[1] < ints2[1]
        //2.吞并：ints1[1] > ints2[1]
        List<int[]> ans = new ArrayList<>();
        int[] pre = res.get(0);
        int len = res.size();
        if(len == 1){
            ans.add(pre);
        }
        for(int i = 1;i < len; i++){
            int[] ints1 = pre;
            int[] ints2 = res.get(i);
            if(ints1[1] < ints2[0]){
                ans.add(pre);
                pre = ints2;
            }
            if(ints1[1] >= ints2[0] && ints1[1] < ints2[1]){
                pre = new int[]{ints1[0],ints2[1]};
            }else if(ints1[1] >= ints2[1]){
                pre = new int[]{ints1[0],ints1[1]};
            }
            if(i == len-1){
                ans.add(pre);
            }
        }
        int size = ans.size();
        int[][] result = new int[size][];
        for(int i = 0;i < size;i++){
            result[i] = ans.get(i);
        }
        return result;
    }
}
```

**总结**

```
数据结构掌握的很烂 所以写的比较复杂 但我感觉其实还好啦
就是考虑以下两种合并情况就行
1.交叉：ints1[1] >= ints2[0] && ints1[1] < ints2[1]
2.吞并：ints1[1] > ints2[1]
```

**Hot24**

**题目描述**

```
给你一个 无重叠的 ，按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。
```

**实例**

```
输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
输出：[[1,5],[6,9]]
```

**题解**

```
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        if(newInterval.length == 0) return intervals;
        if(intervals.length == 0) return new int[][]{newInterval};
        List<int[]> res = new ArrayList<>();
        int L = newInterval[0], R = newInterval[1], len = intervals.length, j = 0;
        while(j < len && intervals[j][1] < L) res.add(intervals[j++]);      //重叠前直接加入List
        while(j < len && intervals[j][0] <= R){     //处理重叠区域
            L = Math.min(L, intervals[j][0]);
            R = Math.max(R, intervals[j++][1]);
        }
        res.add(new int[]{L,R});
        while(j < len) res.add(intervals[j++]);     //不会再出现重叠区域，直接加入List
        return res.toArray(new int[res.size()][]);
    }
}
```

**总结**

```
我他喵的是个煞笔
就直接遍历 分析三种情况 
while(j < len && intervals[j][0] <= R){     //处理重叠区域
	L = Math.min(L, intervals[j][0]);
	R = Math.max(R, intervals[j++][1]);
}
这一段写的是真的漂亮 
相比于上一题我if else傻逼写法 他这个while循环的条件就是必定会有合并区间 
然后就一直循环就行 循环体内找到左端点和右端点
```

**Hot25**

**题目描述**

```
给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。
```

**实例**

```
输入：s = "Hello World"
输出：5
解释：最后一个单词是“World”，长度为5。
```

**题解**

```
class Solution {
    public int lengthOfLastWord(String s) {
        String[] list = s.split(" ");
        String str = list[list.length-1];
        return str.length();
    }
}
```

**总结**

```
水题 就是要记一下 split的用法 返回一个String数组
```

**Hot26**

**题目描述**

```
给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。
```

**实例**

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

**题解**

```
class Solution {
        public int[][] generateMatrix(int n) {
        int[][] res = new int[n][n];
        int up = 0, down = n - 1, left = 0, right = n - 1, index = 1;
        while(index <= n * n){
            for(int i = left; i <= right; i++){
                res[up][i] = index++;
            }
            up++;
            for(int i = up; i <= down; i++){
                res[i][right] = index++;
            }
            right--;
            for(int i = right; i >= left; i--){
                res[down][i] = index++;
            }
            down--;
            for(int i = down; i >= up; i--){
                res[i][left] = index++;
            }
            left++;
        }
        return res;
    }
}
```

**总结**

```
我不会我是傻逼 
用模拟的方法 模拟这个二维数组形成的过程 对四个操作套一个while循环就可以模拟了
```

**Hot27**

**题目描述**

```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？
```

**实例**

```
输入：m = 3, n = 7
输出：28
```

**题解**

```
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        //从0，0到m-1，n-1
        for(int i = 0;i < m;i++){
            dp[i][n-1] = 1;
        }
        for(int i = 0;i < n;i++){
            dp[m-1][i] = 1;
        }
        for(int i = m - 2;i >= 0;i--){
            for(int j = n-2 ;j >=0; j--){
                dp[i][j] = dp[i+1][j] + dp[i][j+1];
            }
        }
        return dp[0][0];
    }
}
```

**总结**

```
动态规划入门题
```

**Hot28**

**题目描述**

```
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。
```

**实例**

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**题解**

```
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        dp[m-1][n-1] = grid[m-1][n-1];
        for(int i = m-1; i >=0 ;i--){
            for(int j = n-1; j >= 0; j--){
                int min = grid[i][j];
                if(i != m-1 && j != n-1){
                    min += Math.min(dp[i][j+1],dp[i+1][j]);
                    dp[i][j] = min;
                    continue;
                }
                if(i != m-1){
                    min += dp[i+1][j];
                }
                if(j != n-1){
                    min += dp[i][j+1];
                }
                dp[i][j] = min;
            }
        }
        return dp[0][0];
    }
}
```

**总结**

```
动态规划入门题+1
```

**Hot30**

**题目描述**

```
给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

必须在不使用库的sort函数的情况下解决这个问题。
```

**实例**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**题解**

```
class Solution {
    public void sortColors(int[] nums) {
        int red = 0;
        List<Integer> list = new ArrayList<>();
        int len = nums.length;
        for(int i = 0; i < len;i++){
            int num = nums[i];
            if(num == 0){
                red++;
                list.add(0,0);
            }
            if(num == 1){
                list.add(red,1);
            }
            else{
                list.add(2);
            }
        }
        int[] res = new int[len];
        for(int i = 0;i < len;i++){
            nums[i] = list.get(i);
        }
    }
}
```

**总结**

```
动态规划入门题+1
```

**Hot30**

**题目描述**

```
给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

必须在不使用库的sort函数的情况下解决这个问题。
```

**实例**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**题解**

```
class Solution {
    public void sortColors(int[] nums) {
        int red = 0;
        List<Integer> list = new ArrayList<>();
        int len = nums.length;
        for(int i = 0; i < len;i++){
            int num = nums[i];
            if(num == 0){
                red++;
                list.add(0,0);
            }
            if(num == 1){
                list.add(red,1);
            }
            else{
                list.add(2);
            }
        }
        int[] res = new int[len];
        for(int i = 0;i < len;i++){
            nums[i] = list.get(i);
        }
    }
}
```

**总结**

```
简单题 不难
```

**Hot31**

**题目描述**

```
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
```

**实例**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**题解**

```
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        res.add(new ArrayList<Integer>());
        dfs(new ArrayList<Integer>(),nums,0);
        return res;
    }
    public void dfs(List<Integer> path,int[] nums,int idx){
        if(idx == nums.length){
            return;
        }
        int num = nums[idx];
        //1.选择当前节点
        List<Integer> newpath = new ArrayList<>(path);
        newpath.add(num);
        res.add(newpath);
        dfs(newpath,nums,idx+1);
        //2.不选当前节点
        dfs(path,nums,idx+1);
    }
}
```

**总结**

```
就是简单的递归
```

**Hot32**

**题目描述**

```
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
```

**实例**

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

**题解**

```
class Solution {
    public boolean exist(char[][] board, String word) {
        for (int i = 0; i < board.length; ++i) {
            for (int j = 0; j < board[i].length; ++j) {
                if (board[i][j] == word.charAt(0)) {
                    if (dfs(board, word, i, j, 0)) return true;
                }
            }
        }
        return false;
    }
    public boolean dfs(char[][] board, String word, int i, int j, int k) {
        if (k == word.length()) {
            return true;
        }
        if (i < 0 || j < 0 || i >= board.length || j >= board[i].length) {
            return false;
        }
      
        if (word.charAt(k) != board[i][j]) {
            return false;
        }
        char t = board[i][j]; //记录一下
        board[i][j] = '0';//用过了就不能用了 把他改成不可能匹配的数字
        boolean res = dfs(board, word, i + 1, j, k + 1) || 
        dfs(board, word, i - 1, j, k + 1) || 
        dfs(board, word, i, j + 1, k + 1) || 
        dfs(board, word, i, j - 1, k + 1);
        board[i][j] = t;//改回来
        return res;
    }
}
```

**总结**

```
这道题就是暴力递归 但是需要标记走过的节点，然后进行回溯
```

**Hot33**

**题目描述**

```
给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。
```

**实例**

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**题解**

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        dfs(root,res);
        return res;
    }
    public void dfs(TreeNode root,List<Integer> res){
        if(root == null){
            return;
        }
        if(root.left != null){
            dfs(root.left,res);
        }
        res.add(root.val);
        if(root.right != null){
            dfs(root.right,res);
        }
    }
}
```

**总结**

```
中序遍历就是水啦
```

**Hot34**

**题目描述**

```
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
```

**实例**

```
输入：n = 3
输出：5
```

**题解**

```
class Solution {
    public int numTrees(int n) {
        int[] G = new int[n + 1];
        G[0] = 1;
        G[1] = 1;

        for (int i = 2; i <= n; ++i) {
            for (int j = 1; j <= i; ++j) {
                G[i] += G[j - 1] * G[i - j];
            }
        }
        return G[n];
    }
}
```

**总结**

```
二叉搜索树就是满足每一个根节点都满足左孩子<根节点<右节点 
并且整个树按照中序遍历递增 
所以就可以进行动态规划 动态规划的本质是结果缓存递推 所以不如说可以进行结果缓存递推
因为k个节点所能够生成的二叉搜索树是一定的
所以本题有缓存 而且本题还要用到笛卡尔积
```

**Hot35**

**题目描述**

```
给你一个二叉树的根节点 root ， 检查它是否轴对称。
```

**实例**

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**题解**

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return duichen(root.left,root.right);
    }
    public boolean duichen(TreeNode node1,TreeNode node2){
        if(node1 == null && node2 == null){
            return true;
        }
        if(node1 == null && node2 != null){
            return false;
        }
        if(node2 == null && node1 != null){
            return false;
        }
        if(node1.val != node2.val){
            return false;
        }
        return duichen(node1.left,node2.right) & duichen(node1.right,node2.left);
    }
}
```

**总结**

```
有效 二叉搜索树定义如下：

1.节点的左子树只包含 小于 当前节点的数。
2.节点的右子树只包含 大于 当前节点的数。
3.所有左子树和右子树自身必须也是二叉搜索树。
我们就根据这个来dfs
容易知道，这个dfs必定是带参下潜 因为要比较子树的值和max以及min的关系、
4
```

**Hot36**

**题目描述**

```
给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效 二叉搜索树定义如下：

节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
```

**实例**

```
输入：root = [2,1,3]
输出：true
```

**题解**

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return duichen(root.left,root.right);
    }
    public boolean duichen(TreeNode node1,TreeNode node2){
        if(node1 == null && node2 == null){
            return true;
        }
        if(node1 == null && node2 != null){
            return false;
        }
        if(node2 == null && node1 != null){
            return false;
        }
        if(node1.val != node2.val){
            return false;
        }
        return duichen(node1.left,node2.right) & duichen(node1.right,node2.left);
    }
}
```

**总结**

```
我的想法就是比较两个子树是否是对称的 递归就行
```

**Hot37**

**题目描述**

```
给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。
```

**实例**

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**题解**

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if(root == null){
            return res;
        }
        queue.add(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            for(int i = 0;i < size; i++){
            TreeNode node = queue.poll();
                if(node.left != null){
                    queue.add(node.left);
                }
                if(node.right != null){
                    queue.add(node.right);
                }
                list.add(node.val);
            }
            res.add(list);
        }
        return res;
    }
}
```

**总结**

```
层序遍历用队列来实现 唯一需要注意的点就是 队列的size需要提前记录一下
```

**Hot37**

**题目描述**

```
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，
```

**实例**

```
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
```

**题解**

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;
    }
}
```

**总结**

```
嗯 dfs 秒 
感觉dfs的就是递归的思路
```

**Hot38**

**题目描述**

```
给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点
```

**实例**

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

**题解**

```
class Solution {
    private Map<Integer, Integer> indexMap;

    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left > preorder_right) {
            return null;
        }

        // 前序遍历中的第一个节点就是根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = indexMap.get(preorder[preorder_root]);
      
        // 先把根节点建立出来
        TreeNode root = new TreeNode(preorder[preorder_root]);
        // 得到左子树中的节点数目
        int size_left_subtree = inorder_root - inorder_left;
        // 递归地构造左子树，并连接到根节点
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        // 递归地构造右子树，并连接到根节点
        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        // 构造哈希映射，帮助我们快速定位根节点
        indexMap = new HashMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
}

```

**总结**

```
典型的递归 大问题和小问题 都是在一定范围内构造正确的树
突然想到 递归可以这么来理解
一个大问题可以拆成多个小问题 其中大问题和小问题的题位是一样
题位：对于一个问题 我们所站的位置
然后思考一下大问题如果转化为小问题就可以
本题是根据先序遍历的第一个数确定根节点 再从中序遍历中找到这个数 从而确定左子树和右子树的范围 也就是确定了小问题:在新的更小的范围内构造正确的树
```

**Hot39**

**题目描述**

```
给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同
```

**实例**

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**题解**

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        List<TreeNode> list = new ArrayList<>();
        dfs(root,list);
        for(int i = 0; i < list.size() - 1; i++){
            TreeNode node = list.get(i);
            TreeNode nextNode = list.get(i+1);
            node.left = null;
            node.right = nextNode;
        }
    }   
    public void dfs(TreeNode node,List<TreeNode> list){
        if(node == null){
            return;
        }
        list.add(node);
        dfs(node.left,list);
        dfs(node.right,list);
    }
}
```

**总结**

```
没什么技巧性 就是先先序遍历一边 然后串起来就行
```

**Hot40**

**题目描述**

```
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
```

**实例**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**题解**

```
class Solution {
    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE;
        int res = Integer.MIN_VALUE;
        for(int i = 0;i < prices.length ;i++){
            if(prices[i] > min){
                res = Math.max(prices[i] - min,res);
            }else{
                min = prices[i];
            }
        }
        return res == Integer.MIN_VALUE ? 0 : res;
    }
}
```

**总结**

```
简单题
```

**Hot41**

**题目描述**

```
路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。
```

**实例**

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**题解**

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int max = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        max = Math.max(dfs(root),max);
        return max;
    }
    public int dfs(TreeNode root){
        //单独判断左右连起来的情况
        if(root == null){
            return -1000;
        }
        int num = root.val;
        int leftMax = dfs(root.left);
        int rightMax = dfs(root.right);
        System.out.println(leftMax + " " + rightMax);
        max = Math.max(num + leftMax + rightMax,max);//
        int m = Math.max(leftMax,rightMax);
        max = Math.max(m,max);
        if(m > 0){
            num += m;
        }
        return num;
    }
}
```

**总结**

```
思路 就是不断进行比较max和可能出现的最大值
首先是要比较左右串起来的情况
然后向上返回当前节点和左边或者右边能连起来的最大路径
这里空节点我返回-1000可能需要改进
```

**Hot42**

**题目描述**

```
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
```

**实例**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**题解**

```
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> num_set = new HashSet<Integer>();
        for (int num : nums) {
            num_set.add(num);
        }

        int longestStreak = 0;

        for (int num : num_set) {
            //这样就会匹配到连续序列中最小的那个
            //遍历每个连续序列(从该序列中最小的那个开始查找)
            if (!num_set.contains(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                while (num_set.contains(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }

                longestStreak = Math.max(longestStreak, currentStreak);
            }
        }

        return longestStreak;
    }
}
```

**总结**

```
将数组中的元素存入集合中 这样查询的效率就是O(1)
遍历每个连续序列(从该序列中最小的那个开始查找)
```

**Hot43**

**题目描述**

```
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
```

**实例**

```
输入: [2,2,1]
输出: 1
```

**题解**

```
class Solution {
    public int singleNumber(int[] nums) {
        int num  = 0;
        for(int i : nums){
            num ^= i;
        }
        return num;
    }
}
```

**总结**

```
位运算方便
当然也可以用hash表
```

**Hot44**

**题目描述**

```
给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
```

**实例**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。xxxxxxxxxx 输入: s = "leetcode", wordDict = ["leet", "code"]输出: true解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。输入: [2,2,1]输出: 1
```

**题解**

```
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int len = s.length();
        boolean[] dp = new boolean[len+1];
        dp[0] = true;
        for(int i = 1; i < len+1; i++){ //i指的是长度
            for(String str: wordDict){
                int length = str.length();
                if(i >= length){
                    String newstr = s.substring(i-length,i);
                    if(newstr.equals(str)){
                        dp[i] |= dp[i-length];
                    }
                }
            }
        }
        return dp[len];
    }
}
```

**总结**

```
凑单词还是和爬楼梯一样的思路 dp[x] 下标x表示能否拼凑出长度为x的字符串
```

**Hot45**

**题目描述**

```
给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表
```

**实例**

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**题解**

```
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null){
            return head;
        }
        ListNode fast = head;
        ListNode slow = head;
        while(fast.next != null && fast.next.next != null){
            fast = fast.next.next;
            slow = slow.next;
            if(slow == fast){
                if(slow == head){
                    return head;
                }
                fast = head;
                while(true){
                    fast = fast.next;
                    slow = slow.next;
                    if(fast == slow){
                        return fast;
                    }
                }
            }
        }
        return null;
    }
}
```

**总结**

```
这道题和环形链表I不一样，这个还需要再次将fast置于head位置
然后和slow一起向后遍历，直到fast==slow，最终会合的位置就是二者相遇的位置
```

**Hot46**

**题目描述**

```
请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。
实现 LRUCache 类：
LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。
```

**实例**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

**题解**

```
class LRUCache {
    //用hash表来记录吧
    private Map<Integer,Integer> mymap = new HashMap<>();
    private Deque<Integer> queue = new LinkedList<>();
    private int capacity = 0;
    public LRUCache(int capacity) {
        this.capacity = capacity;
    }
  
    public int get(int key) {
        if(mymap.get(key) == null){
            return -1;
        }
        queue.remove(key);
        queue.addLast(key);
        return mymap.get(key);
    }
  
    public void put(int key, int value) {
        Map<Integer,Integer> map = new HashMap<>();
        if(mymap.get(key) != null){
            queue.remove(key);
            queue.addLast(key);
            mymap.put(key,value);
        }else{
            if(mymap.size() == capacity){
                Integer removeKey = queue.removeFirst();
                mymap.remove(removeKey); //删除指定元素
                queue.addLast(key);
                mymap.put(key,value);
            }else{
                queue.addLast(key);
                mymap.put(key,value);
            }
        }
    }
}


/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

**总结**

```
nnd 只击败了5％ 看了一眼题解 和题解差不多 
题解手写了一下双端队列 而我这个菜鸡只会调用api
```

**Hot47**

**题目描述**

```
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。
```

**实例**

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

**题解**

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        List<Integer> list = new ArrayList<>();
        ListNode p = head;
        while(p != null){
            list.add(p.val);
            p = p.next;
        }
        list.sort(new Comparator<Integer>() {
            @Override
            public int compare(Integer n1, Integer n2) {
                return n1-n2;
            }
        });

        ListNode newhead = new ListNode();
        p = newhead;
        for(int i : list){
            ListNode node = new ListNode(i);
            p.next = node;
            p = p.next;
        }
        return newhead.next;
    }
  
}
```

**总结**

```
我是笨比 只会笨方法
还是复习一下 list.sort的写法 需要传递一个comparator并且重写comparable方法
```

**Hot48**

**题目描述**

```
给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 32-位 整数。

子数组 是数组的连续子序列
```

**实例**

```
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**题解**

```
class Solution {
    public int maxProduct(int[] nums) {
        int maxF = nums[0], minF = nums[0], ans = nums[0];
        int length = nums.length;
        for (int i = 1; i < length; ++i) {
            int mx = maxF, mn = minF;
            maxF = Math.max(mx * nums[i], Math.max(nums[i], mn * nums[i]));
            minF = Math.min(mn * nums[i], Math.min(nums[i], mx * nums[i]));
            ans = Math.max(maxF, ans);
        }
        return ans;
    }
}
```

**总结**

```
我是真的傻逼 
暴力递归会超时 常规动态规划也会
本题其实就是她娘的暴力
最大值只会在前一个位置最大值 * 当前位置的值
和 前一个位置最小值 * 当前位置的值 和 当前位置的值
中产生
所以我们只需要维护最小值和最大值就行了 
```

**Hot49**

**题目描述**

```
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。
```

**实例**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**题解1**

```
class MinStack {
    Deque<Integer> queue = new LinkedList<>();
    Map<Integer,Integer> map = new HashMap<>();
    public MinStack() {
      
    }
  
    public void push(int val) {
        queue.addLast(val);
        if(queue.size() == 1){
            map.put(queue.size(),val);
        }else{
            int premin =  map.get(queue.size() - 1);
            if(val < premin){
                map.put(queue.size(),val);
            }else{
                map.put(queue.size(),premin);
            }
        }

    }
  
    public void pop() {
        queue.removeLast();
    }
  
    public int top() {
        return queue.getLast();
    }
  
    public int getMin() {
        return map.get(queue.size());
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

**题解2 辅助栈**

```
class MinStack {
    Deque<Integer> xStack;
    Deque<Integer> minStack;

    public MinStack() {
        xStack = new LinkedList<Integer>();
        minStack = new LinkedList<Integer>();
        minStack.push(Integer.MAX_VALUE);
    }
  
    public void push(int x) {
        xStack.push(x);
        minStack.push(Math.min(minStack.peek(), x));
    }
  
    public void pop() {
        xStack.pop();
        minStack.pop();
    }
  
    public int top() {
        return xStack.peek();
    }
  
    public int getMin() {
        return minStack.peek();
    }
}
```

**总结**

```
我的方法比较蠢似乎...
思路就是想记录在某一状态下栈中的最小值
这个状态需要具有唯一性 所以我用map 栈的容量为key 当前的min为value
利用map更新覆盖的原理 制造唯一性
其实我们可以用辅助栈的方法
辅助栈的思路 ： 
主栈执行一些操作的时候，栈中元素的信息发生了变化 这个信息随着操作的变化可能发生改变
为了记录下每次的信息 我们可以用一根辅助栈来和主栈进行对照记录
```

**Hot50**

**题目描述**

```
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

图示两个链表在节点 c1 开始相交：
```

**实例**

```
题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构。
```

**题解1 笨比方法**

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA == headB){
            return headA;
        }
        Set<ListNode> set = new HashSet<>();
        set.add(headA);
        set.add(headB);
        while(headA != null && headB != null){
            headA = headA.next;
            if(!set.contains(headA)){
                set.add(headA);
            }else{
                return headA;
            }
            headB = headB.next;
            if(!set.contains(headB)){
                set.add(headB);
            }else{
                return headB;
            }
        }
        while(headA != null){
             headA = headA.next;
            if(!set.contains(headA)){
                set.add(headA);
            }else{
                return headA;
            }
        }
        while(headB != null){
            headB = headB.next;
            if(!set.contains(headB)){
                set.add(headB);
            }else{
                return headB;
            }
        }
        return null;
    }
}
```

**题解2**

```
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) return null;
    ListNode pA = headA, pB = headB;
    while (pA != pB) {
        pA = pA == null ? headB : pA.next;
        pB = pB == null ? headA : pB.next;
    }
    return pA;
}
```

**总结**

​![相交链表.png](https://pic.leetcode-cn.com/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png)​

**Hot51**

**题目描述**

```
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
```

**实例**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**题解**

```
class Solution {
    public int rob(int[] nums) {
        //我感觉一维的就能搞定呀
        int n = nums.length;
        int[] dp = new int[n+1];
        dp[0] = nums[0];
        if(n == 1){
            return dp[0];
        }
        dp[1] = Math.max(nums[0],nums[1]);
        if(n == 2){
            return dp[1];
        }
        for(int i = 2;i < n;i++){
            dp[i] = Math.max(nums[i] + dp[i-2],dp[i-1]);
        }
        return dp[n-1];
    }
}
```

**总结**

```
简单的一维dp
```

**Hot52**

**题目描述**

```
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。
```

**实例**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**题解**

```
class Solution {
    int[][] dirs = new int[][]{{-1,0}, {1,0}, {0,-1}, {0,1}};
    public int numIslands(char[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int sum = 0;
        for(int i = 0;i < m; i++){
            for(int j = 0;j < n; j++){
                if(grid[i][j] == '1'){
                    sum++;
                    dfs(grid,i,j);
                }
            }
        }
        return sum;
    }

    public void dfs(char[][] grid,int i,int j){
        int m = grid.length;
        int n = grid[0].length;
        if(i >= m || j >= n || i < 0 || j < 0){
            return;
        }
        if(grid[i][j] == '0'){
            return;
        }
        grid[i][j] = '0';
        for(int[] dir : dirs){
            int nexti = i + dir[0];
            int nextj = j + dir[1];
            dfs(grid,nexti,nextj);
        }
    }
}
```

**总结**

```
对先遍历到的1加到结果集中，并且清除与其相邻的1 直接dfs暴力递归就行
预先设置dir数组会提供方便
```

hot53

**题目描述**

```
二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的4个方向连通的 0 组成的群，封闭岛是一个 完全 由1包围（左、上、右、下）的岛。

请返回 封闭岛屿 的数目。
```

**实例**

```plaintext
输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
输出：2
解释：
灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。
```

**题解**

```java
class Solution {
    int[][] dirs = new int[][]{{-1,0}, {1,0}, {0,-1}, {0,1}};
    public int closedIsland(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int sum = 0;
        for(int i = 0;i < m; i++){
            for(int j = 0;j < n; j++){
                if(grid[i][j] == 0){
                    boolean res = dfs(grid,i,j);
                    if(res) sum++;
                }
            }
        }
        return sum;
    }

    public boolean dfs(int[][] grid,int i,int j){
        int m = grid.length;
        int n = grid[0].length;
        boolean res = true;
        if(i >= m || j >= n || i < 0 || j < 0){
            return false;
        }
        if(grid[i][j] == 1){
            return true;
        }
        grid[i][j] = 1;
        for(int[] dir : dirs){
            int nexti = i + dir[0];
            int nextj = j + dir[1];
            res &= dfs(grid,nexti,nextj);
        }
        return res;
    }

}
```

**总结**

```
相比于前面一道题 本题主要是要预先判断当前方格是否能连到边缘方格，所以我给dfs加了一个boolean类型的返回值 然后再判断能否给sum加1
```

**hot54**

**题目描述**

```
你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。

例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。
```

**示例**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

**题解**

```java
class Solution {
    //用二维数组来描述有向图
    List<List<Integer>> culs;
    //记录每个数的入度数组
    int[] nums;
    //思路：图的广度优先遍历  
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        culs = new ArrayList<List<Integer>>();
        nums = new int[numCourses];
        for(int i = 0;i < numCourses; i++){
            culs.add(new ArrayList<>());
        }
        for(int[] culOrder : prerequisites){
            int preCul = culOrder[1];
            int nextCul = culOrder[0];
            culs.get(preCul).add(nextCul);
            nums[nextCul]++;
        }
        Queue<Integer> queue = new LinkedList<>();
        //将度数为0的数加入队列,完成图的bfs
        for(int i = 0;i < numCourses; i++){
            if(nums[i] == 0){
                queue.offer(i);
            }
        }
      
        int visits = 0;
        //队列中只存放入度为0的
        while(!queue.isEmpty()){
            visits++;
            int cul = queue.poll();
            for(int nextCul : culs.get(cul)){
                nums[nextCul]--;
                if(nums[nextCul] == 0){
                    queue.offer(nextCul);
                }
            }
        }
      
        //记录被遍历到的节点数
        if(visits == numCourses){
            return true;
        }else{
            return false;
        }

        //会存在死循环

    }
}

```

**总结**

```text
本题主要考察是图的广度遍历
本题可以简化为求有向图中是否有环
可以采用图的广度遍历 如果形成死锁环形结构 则无法遍历到死锁环中的节点(因为我们根据入度为0来判断可以遍历到，死锁环中的节点入度至少为1)
图的广度遍历方法:还是用队列
通过二维数组来保存图的节点
```


**hot55**

**题目描述**

```
Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

```

**示例**

```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```

**题解**

```java
class Trie {
    private Trie[] children;
    private boolean isEnd;

    public Trie() {
        isEnd = false;
        children = new Trie[26];
    }
  
    public void insert(String word) {
        Trie node = this;
        for(int i = 0;i < word.length();i++){
            char ch = word.charAt(i);
            int index = ch - 'a';
            if(node.children[index] == null){
                node.children[index] = new Trie();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }
  
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node!=null && node.isEnd;
    }

    public Trie searchPrefix(String word){
        Trie node = this;
        for(int i = 0;i < word.length();i++){
            char ch = word.charAt(i);
            int index = ch - 'a';
            if(node.children[index] = null){
                return null;
            }else{
                node =node.children[index];
            }
        }
        return node;
    }
  
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

**总结**

```plaintext
本题就是字典树的板子
字典树就是由一个children数组和一个isEnd标志位
还有两个基本的函数
插入insert 和 searchPrefix
```

**hot56**

**题目描述**

```
给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。
```

**示例**

```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**题解**

```java
class Solution 
{
    public int findKthLargest(int[] nums, int k) 
    {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int x : nums){
            if(minHeap.size() != k){
                minHeap.offer(x);
            }else{
                if(x > minHeap.peek()){
                    minHeap.poll();
                    minHeap.offer(x);
                }
            }
        }
        return minHeap.peek();
    }
}


```

**总结**

```plaintext
又是一道板子题
求第k大/小就是要用优先队列
for(x:[]){
{
	if(size == k){

	}else{
	     add 
	}
}
懂我意思吧
```

‍
